1
00:00:00,031 --> 00:00:04,356
我觉得现在面向消费者的代理有点被过度炒作了

2
00:00:04,556 --> 00:00:07,634
试图让一个代理完全为你预订假期

3
00:00:07,634 --> 00:00:10,303
几乎就像自己去预订一样困难

4
00:00:10,343 --> 00:00:15,763
今天我们将深入探讨我们最近的一篇博客文章

5
00:00:15,763 --> 00:00:17,932
构建有效的代理 

6
00:00:17,952 --> 00:00:20,736
我是Alex 我在Anthropic负责云关系

7
00:00:20,756 --> 00:00:22,558
我是Eric 我在Anthropic的研究团队

8
00:00:22,818 --> 00:00:24,520
我是Barry 我在应用AI团队

9
00:00:24,685 --> 00:00:25,767
我来开个头

10
00:00:26,007 --> 00:00:28,191
对于刚加入的观众

11
00:00:28,191 --> 00:00:31,195
代理的快速定义是什么 

12
00:00:31,396 --> 00:00:31,896
我的意思是

13
00:00:31,896 --> 00:00:32,897
关于它的定义有无数种

14
00:00:33,580 --> 00:00:38,768
为什么开发者或正在用AI构建东西的人应该关心这些 

15
00:00:39,910 --> 00:00:41,192
Eric 也许我们可以从你开始

16
00:00:41,172 --> 00:00:41,493
当然

17
00:00:41,933 --> 00:00:42,292
是的

18
00:00:42,292 --> 00:00:45,711
所以我认为我们在博客文章中探讨的一点是

19
00:00:45,711 --> 00:00:46,071
首先

20
00:00:46,071 --> 00:00:48,410
很多人一直在说一切都是代理

21
00:00:48,410 --> 00:00:51,828
指的是几乎任何超过单一LLM调用的东西

22
00:00:52,130 --> 00:00:56,171
我们在博客文章中尝试做的一件事是真正区分开来

23
00:00:56,171 --> 00:00:56,539
比如

24
00:00:56,539 --> 00:00:57,274
有工作流

25
00:00:57,274 --> 00:01:00,580
这是你有几个LLM调用链在一起的地方

26
00:01:01,181 --> 00:01:03,789
我们真正认为代理是

27
00:01:03,789 --> 00:01:07,267
你让LLM决定运行多少次

28
00:01:07,287 --> 00:01:08,632
你让它继续循环

29
00:01:08,632 --> 00:01:10,170
直到找到解决方案

30
00:01:10,811 --> 00:01:14,234
这可能是与客户交谈以提供客户支持

31
00:01:14,595 --> 00:01:16,737
这可能是迭代代码更改

32
00:01:16,817 --> 00:01:20,336
但有些东西你不知道完成它需要多少步骤

33
00:01:20,336 --> 00:01:22,682
这就是我们真正认为的代理

34
00:01:22,703 --> 00:01:24,004
有趣

35
00:01:23,984 --> 00:01:25,434
在代理的定义中

36
00:01:25,434 --> 00:01:28,128
我们让LLM选择自己的命运

37
00:01:28,128 --> 00:01:29,578
决定它想做什么

38
00:01:29,578 --> 00:01:30,822
采取什么行动

39
00:01:30,822 --> 00:01:33,515
而不是我们为它预先定义路径

40
00:01:33,696 --> 00:01:34,176
正是如此

41
00:01:34,196 --> 00:01:35,321
它更加自主

42
00:01:35,321 --> 00:01:36,221
而工作流

43
00:01:36,221 --> 00:01:39,147
你可以把它想象成一个工作流

44
00:01:39,147 --> 00:01:43,648
或者它是通过固定数量的步骤在轨道上运行的

45
00:01:43,928 --> 00:01:44,249
我明白了

46
00:01:44,509 --> 00:01:46,070
所以这种区分

47
00:01:46,070 --> 00:01:48,934
我猜这是与客户多次对话

48
00:01:48,934 --> 00:01:53,619
与不同团队合作甚至自己尝试事情的结果

49
00:01:53,870 --> 00:01:59,245
Barry 你能多谈谈在我们创建这种工作流和代理之间的区分时

50
00:01:59,245 --> 00:02:00,500
这看起来像什么

51
00:02:00,500 --> 00:02:02,113
以及在你经历这些时

52
00:02:02,113 --> 00:02:03,904
哪些模式最让你惊讶 

53
00:02:04,306 --> 00:02:04,927
当然

54
00:02:05,367 --> 00:02:05,830
老实说

55
00:02:05,830 --> 00:02:10,155
我认为所有这些都随着模型变得更好和团队变得更加复杂而演变

56
00:02:10,535 --> 00:02:13,876
我们都与许多非常复杂的客户合作过

57
00:02:13,876 --> 00:02:16,034
我们从拥有一个LLM

58
00:02:16,034 --> 00:02:17,760
到拥有很多LLM

59
00:02:17,760 --> 00:02:20,350
最终让LLM自己编排自己

60
00:02:20,330 --> 00:02:21,563
所以我们决定

61
00:02:21,563 --> 00:02:23,826
创建这种区分的原因之一

62
00:02:23,826 --> 00:02:25,676
是因为我们开始看到

63
00:02:25,676 --> 00:02:27,322
这两种不同的模式

64
00:02:27,322 --> 00:02:30,406
其中你有由代码预先编排的工作流

65
00:02:30,406 --> 00:02:31,846
然后你也有代理

66
00:02:31,846 --> 00:02:34,725
这在其他意义上更简单但更复杂

67
00:02:34,725 --> 00:02:37,399
就像我们开始看到的不同形状

68
00:02:38,621 --> 00:02:39,026
真的

69
00:02:39,026 --> 00:02:42,673
我认为随着模型和所有工具开始变得更好

70
00:02:42,673 --> 00:02:44,497
代理变得越来越普遍

71
00:02:44,497 --> 00:02:45,713
越来越有能力

72
00:02:46,081 --> 00:02:47,550
那时我们决定

73
00:02:47,550 --> 00:02:47,795
嘿

74
00:02:47,795 --> 00:02:51,715
这可能是我们给出正式定义的好时机

75
00:02:51,735 --> 00:02:52,560
所以在实践中

76
00:02:52,560 --> 00:02:53,798
如果你是一个开发者

77
00:02:53,798 --> 00:02:55,174
正在实现这些东西之一

78
00:02:55,174 --> 00:02:56,412
当你开始构建这个时

79
00:02:56,412 --> 00:02:58,613
这实际上在你的代码中会是什么样子

80
00:03:01,137 --> 00:03:03,440
也许我们实际上可以深入到提示级别

81
00:03:04,061 --> 00:03:06,846
代理提示看起来像什么或流程是什么

82
00:03:06,846 --> 00:03:08,587
工作流看起来像什么 

83
00:03:09,048 --> 00:03:09,268
是的

84
00:03:09,449 --> 00:03:13,025
所以我认为工作流提示看起来像你有一个提示

85
00:03:13,025 --> 00:03:14,098
你取它的输出

86
00:03:14,098 --> 00:03:16,959
你把它输入到提示B 取那个的输出

87
00:03:16,959 --> 00:03:19,462
输入到提示C 然后你就完成了

88
00:03:19,443 --> 00:03:21,022
有点像是这条直线

89
00:03:21,022 --> 00:03:22,404
固定数量的步骤

90
00:03:22,404 --> 00:03:24,575
你确切地知道会发生什么

91
00:03:25,097 --> 00:03:27,023
也许你有一些额外的代码

92
00:03:27,023 --> 00:03:29,124
这些代码检查这些中间结果

93
00:03:29,124 --> 00:03:30,350
确保它们没问题

94
00:03:31,212 --> 00:03:34,701
但你确切地知道在这些路径之一中会发生什么

95
00:03:34,681 --> 00:03:38,445
每个提示都是非常具体的提示

96
00:03:38,445 --> 00:03:43,656
只是取一个输入并将其转换为另一个输出

97
00:03:44,178 --> 00:03:44,621
例如

98
00:03:44,621 --> 00:03:50,607
也许其中一个提示是接受用户问题并将其分类为五个类别之一

99
00:03:50,607 --> 00:03:54,376
以便下一个提示可以更具体地针对那个

100
00:03:54,357 --> 00:03:55,259
好的

101
00:03:55,279 --> 00:03:56,284
相比之下

102
00:03:56,284 --> 00:03:58,546
代理提示将更加开放

103
00:03:58,546 --> 00:04:03,071
通常会给模型工具或多个东西来检查并说

104
00:04:03,071 --> 00:04:03,322
嘿

105
00:04:03,322 --> 00:04:04,327
这是问题

106
00:04:04,327 --> 00:04:06,590
你可以进行网络搜索

107
00:04:06,590 --> 00:04:11,114
或者你可以编辑这些代码文件或运行代码

108
00:04:11,114 --> 00:04:12,622
并继续这样做

109
00:04:12,622 --> 00:04:14,131
直到你有答案

110
00:04:14,151 --> 00:04:14,712
我明白了

111
00:04:14,692 --> 00:04:16,874
所以那里有几个不同的用例

112
00:04:18,336 --> 00:04:19,056
这很有道理

113
00:04:19,056 --> 00:04:21,218
因为我们开始得出这些不同的结论

114
00:04:21,999 --> 00:04:22,826
我很好奇

115
00:04:22,826 --> 00:04:28,825
既然我们现在已经大致涵盖了我们对这些工作流和代理的思考方式

116
00:04:28,825 --> 00:04:30,480
并谈到了博客文章

117
00:04:30,480 --> 00:04:32,549
我想更深入地探讨幕后

118
00:04:33,070 --> 00:04:35,613
Barry 有没有什么有趣的故事

119
00:04:35,613 --> 00:04:38,156
关于你从客户那里看到的疯狂的事情

120
00:04:38,156 --> 00:04:39,110
这些事很有趣

121
00:04:39,110 --> 00:04:40,381
或者只是有点离谱

122
00:04:40,381 --> 00:04:43,719
关于人们如何开始在生产中实际使用这些东西 

123
00:04:44,054 --> 00:04:44,443
是的

124
00:04:44,443 --> 00:04:47,558
这实际上来自我自己构建代理的经验

125
00:04:47,959 --> 00:04:52,605
我大约在Sonnet v2更新前一个月加入 

126
00:04:52,625 --> 00:04:54,089
我的入职任务之一是

127
00:04:54,089 --> 00:04:55,716
运行OS World

128
00:04:55,716 --> 00:04:57,832
这是一个计算机使用基准测试

129
00:04:57,852 --> 00:04:58,743
整整一周

130
00:04:58,743 --> 00:05:04,981
我和另一位工程师都在盯着这些对我们来说反直觉的代理轨迹 

131
00:05:05,384 --> 00:05:11,794
我们不确定为什么模型会根据我们给出的指令做出这样的决定 

132
00:05:12,675 --> 00:05:15,155
所以我们决定像Cloud一样行动

133
00:05:15,155 --> 00:05:16,860
把自己放在那个环境中 

134
00:05:17,162 --> 00:05:19,481
我们会做这件非常愚蠢的事情

135
00:05:19,481 --> 00:05:21,088
闭上眼睛整整一分钟

136
00:05:21,088 --> 00:05:23,051
然后眨眼看屏幕一秒钟 

137
00:05:23,752 --> 00:05:24,608
我们再次闭上眼睛

138
00:05:24,608 --> 00:05:25,036
只是思考

139
00:05:25,036 --> 00:05:27,497
我必须编写Python代码来在这个环境中操作 

140
00:05:27,798 --> 00:05:28,379
我会怎么做 

141
00:05:28,799 --> 00:05:29,244
突然间

142
00:05:29,244 --> 00:05:30,581
这变得更有意义了 

143
00:05:30,562 --> 00:05:33,626
我觉得很多代理设计都归结于此 

144
00:05:33,767 --> 00:05:38,013
模型可能没有很多上下文和知识 

145
00:05:38,594 --> 00:05:40,857
我们必须对模型有同理心 

146
00:05:41,278 --> 00:05:42,622
我们必须在提示

147
00:05:42,622 --> 00:05:45,504
工具描述和环境中明确很多内容 

148
00:05:45,824 --> 00:05:46,125
我明白了 

149
00:05:46,145 --> 00:05:49,243
所以这里给开发者的一个建议是

150
00:05:49,243 --> 00:05:53,228
几乎要像通过模型本身的镜头来看待问题

151
00:05:53,228 --> 00:05:53,670
比如

152
00:05:53,670 --> 00:05:56,327
这里最适用的指令是什么 

153
00:05:56,347 --> 00:05:58,230
模型是如何看待世界的

154
00:05:58,230 --> 00:06:01,432
这与我们作为人类操作的方式非常不同

155
00:06:01,432 --> 00:06:01,809
我想

156
00:06:01,809 --> 00:06:03,504
有额外的上下文吗 

157
00:06:04,632 --> 00:06:07,057
Eric 我很好奇你是否见过其他故事 

158
00:06:07,357 --> 00:06:07,879
是的

159
00:06:07,879 --> 00:06:10,492
我认为实际上非常相似

160
00:06:10,492 --> 00:06:14,410
我认为很多人真的忘记了这样做 

161
00:06:14,992 --> 00:06:17,517
我认为我见过的最有趣的事情是

162
00:06:17,517 --> 00:06:21,845
人们会投入很多精力来创建这些非常漂亮详细的提示 

163
00:06:22,627 --> 00:06:29,482
然后他们为模型制作的工具却是这些极其简陋的

164
00:06:29,482 --> 00:06:30,788
没有文档

165
00:06:30,788 --> 00:06:35,032
参数命名为A和B 这有点像

166
00:06:35,032 --> 00:06:35,358
哦

167
00:06:35,358 --> 00:06:39,602
工程师如果必须使用这个函数

168
00:06:39,602 --> 00:06:41,234
也无法工作

169
00:06:41,234 --> 00:06:43,519
因为没有文档 

170
00:06:43,561 --> 00:06:47,006
你怎么能指望Claude也能使用这个呢 

171
00:06:47,026 --> 00:06:49,590
所以这有点像没有设身处地 

172
00:06:50,091 --> 00:06:51,092
我认为...

173
00:06:51,072 --> 00:06:52,238
我认为很多人

174
00:06:52,238 --> 00:06:55,932
当他们开始尝试使用工具使用和函数调用时

175
00:06:55,932 --> 00:06:58,848
他们有点忘记了他们也必须提示 

176
00:06:58,908 --> 00:07:04,379
他们把模型仅仅看作一个更经典的编程系统 

177
00:07:04,419 --> 00:07:05,401
但它仍然是一个模型 

178
00:07:05,862 --> 00:07:09,570
你需要在你的工具描述中进行提示工程 

179
00:07:09,652 --> 00:07:10,112
是的

180
00:07:10,112 --> 00:07:11,495
我注意到了 

181
00:07:11,535 --> 00:07:14,379
就像人们忘记了这都是同一个提示的一部分 

182
00:07:14,399 --> 00:07:17,557
就像它都被输入到上下文窗口中的同一个提示中

183
00:07:17,557 --> 00:07:20,867
编写一个好的工具描述也会影响提示的其他部分 

184
00:07:20,887 --> 00:07:22,790
所以这是需要考虑的一个方面 

185
00:07:24,172 --> 00:07:29,099
代理现在是这种热门话题 

186
00:07:29,419 --> 00:07:31,493
很多人都在谈论它

187
00:07:31,493 --> 00:07:36,420
已经有很多文章和视频制作关于这个主题 

188
00:07:36,441 --> 00:07:40,772
是什么让你们认为现在是时候自己写点东西

189
00:07:40,772 --> 00:07:43,508
更多地谈论代理的细节了 

190
00:07:45,110 --> 00:07:45,446
当然

191
00:07:45,446 --> 00:07:45,950
是的 

192
00:07:46,471 --> 00:07:51,216
我认为对我们来说最重要的事情之一是能够很好地解释事情 

193
00:07:51,616 --> 00:07:54,628
我认为这是我们动机的一个重要部分

194
00:07:54,628 --> 00:07:56,134
我们走进客户会议

195
00:07:56,134 --> 00:07:58,205
一切都被称为不同的术语

196
00:07:58,205 --> 00:08:00,465
尽管它们共享相同的形状 

197
00:08:00,445 --> 00:08:01,686
所以我们认为

198
00:08:01,686 --> 00:08:07,891
如果你能有一套定义和一套图表和代码来解释这些事情给我们的客户

199
00:08:07,891 --> 00:08:09,338
那将非常有用 

200
00:08:09,779 --> 00:08:17,691
我们正在达到模型能够执行我们看到的许多代理工作流的程度 

201
00:08:18,032 --> 00:08:24,782
这似乎是我们拥有一些定义或只是让这些对话更容易的合适时机 

202
00:08:25,741 --> 00:08:26,945
我认为对我来说

203
00:08:26,945 --> 00:08:29,182
我看到有很多关于代理的兴奋

204
00:08:29,182 --> 00:08:32,968
但也有很多人真的不知道它在实践中意味着什么 

205
00:08:32,989 --> 00:08:36,665
所以他们试图将代理引入他们遇到的任何问题

206
00:08:36,665 --> 00:08:39,054
即使更简单的系统也能工作 

207
00:08:39,075 --> 00:08:44,205
所以我认为我们应该写这篇文章的原因之一是指导人们如何做代理

208
00:08:44,205 --> 00:08:46,152
但也包括代理适用的地方

209
00:08:46,152 --> 00:08:48,805
以及你不应该用火箭筒去打苍蝇 

210
00:08:49,126 --> 00:08:50,027
我明白了 

211
00:08:50,260 --> 00:08:50,641
我明白了 

212
00:08:50,841 --> 00:08:53,989
这完美地引出了我的下一个问题 

213
00:08:54,029 --> 00:08:57,015
有很多关于代理潜力的讨论 

214
00:08:57,036 --> 00:08:58,125
每个开发者

215
00:08:58,125 --> 00:08:59,472
每个初创公司

216
00:08:59,472 --> 00:09:00,145
和公司

217
00:09:00,145 --> 00:09:01,043
都在思考

218
00:09:01,043 --> 00:09:01,492
如何

219
00:09:01,492 --> 00:09:02,839
为自己的公司

220
00:09:02,839 --> 00:09:03,513
或产品

221
00:09:03,513 --> 00:09:03,962
构建

222
00:09:03,962 --> 00:09:04,635
自己的

223
00:09:04,635 --> 00:09:05,533
代理版本

224
00:09:06,224 --> 00:09:08,347
但你们开始看到什么在生产中实际有效 

225
00:09:08,548 --> 00:09:10,190
所以我们要在这里玩一个小游戏 

226
00:09:10,871 --> 00:09:16,723
我想知道目前关于代理 Agents 的一件事是被过度炒作的

227
00:09:16,723 --> 00:09:18,741
还有一件事是被低估的

228
00:09:18,741 --> 00:09:21,769
就实施或实际生产用途或潜力而言

229
00:09:21,901 --> 00:09:23,984
那么Eric 让我们从你开始

230
00:09:24,124 --> 00:09:27,502
我觉得被低估的是那些能节省人们时间的事情

231
00:09:27,502 --> 00:09:29,530
即使只是节省了很少的时间

232
00:09:30,251 --> 00:09:32,606
我认为很多时候如果你只是表面上看

233
00:09:32,606 --> 00:09:33,195
就会觉得

234
00:09:33,195 --> 00:09:33,342
哦

235
00:09:33,342 --> 00:09:35,256
这只是一件花我一分钟的事情

236
00:09:35,758 --> 00:09:37,447
即使你能完全自动化它

237
00:09:37,447 --> 00:09:38,461
也只是一分钟

238
00:09:38,481 --> 00:09:39,102
那有什么帮助呢 

239
00:09:39,643 --> 00:09:40,589
但实际上

240
00:09:40,589 --> 00:09:42,008
这改变了动态

241
00:09:42,008 --> 00:09:46,030
现在你可以比以前多做100次那件事

242
00:09:46,431 --> 00:09:52,678
所以我认为我最兴奋的是那些如果更容易就能真正扩大规模的事情

243
00:09:52,698 --> 00:09:53,066
是的

244
00:09:53,066 --> 00:09:55,645
我不知道这是否一定与炒作有关

245
00:09:55,645 --> 00:09:59,145
但我认为现在很难校准代理真正需要的地方

246
00:09:59,786 --> 00:10:03,363
我认为有一个交集是使用代理的甜点

247
00:10:03,363 --> 00:10:06,269
那是一组有价值且复杂的任务

248
00:10:06,269 --> 00:10:10,517
但也许错误成本或监控错误的成本相对较低

249
00:10:11,900 --> 00:10:14,082
那组任务并不...

250
00:10:14,450 --> 00:10:17,181
不是非常清晰和明显

251
00:10:17,181 --> 00:10:20,822
除非我们真正查看现有流程

252
00:10:20,843 --> 00:10:24,027
我认为编码和搜索是两个非常典型的例子

253
00:10:24,027 --> 00:10:25,973
代理在这些方面非常有用

254
00:10:27,196 --> 00:10:28,659
以搜索为例

255
00:10:28,699 --> 00:10:31,284
这是一项非常有价值的任务

256
00:10:31,344 --> 00:10:34,230
进行深度迭代搜索非常困难

257
00:10:34,210 --> 00:10:37,053
但你总是可以以一些精度换取召回率

258
00:10:37,053 --> 00:10:39,542
然后得到更多需要的文档或信息

259
00:10:39,542 --> 00:10:40,964
并过滤掉不需要的

260
00:10:41,545 --> 00:10:43,850
所以我们在代理搜索方面看到了很多成功

261
00:10:43,990 --> 00:10:46,195
现在的编码代理是什么样子的 

262
00:10:46,799 --> 00:10:49,471
我认为编码代理非常令人兴奋

263
00:10:49,471 --> 00:10:52,144
因为它们至少部分是可验证的

264
00:10:52,445 --> 00:10:53,979
代码有一个很好的特性

265
00:10:53,979 --> 00:10:55,360
你可以为它编写测试

266
00:10:55,360 --> 00:10:56,281
然后编辑代码

267
00:10:56,281 --> 00:10:57,202
测试要么通过

268
00:10:57,202 --> 00:10:57,969
要么不通过

269
00:10:58,731 --> 00:11:00,591
这假设你有好的单元测试

270
00:11:00,591 --> 00:11:02,959
我认为世界上每个工程师都会说

271
00:11:02,959 --> 00:11:03,636
我们没有

272
00:11:04,637 --> 00:11:06,478
但至少它比很多事情都要好

273
00:11:06,699 --> 00:11:08,001
对于许多其他领域

274
00:11:08,001 --> 00:11:10,282
没有等效的方法可以做到这一点

275
00:11:10,402 --> 00:11:12,064
所以这至少给了...

276
00:11:12,044 --> 00:11:14,596
这给了编码代理一些方式

277
00:11:14,596 --> 00:11:18,078
每次通过循环时都能获得更多信号

278
00:11:18,098 --> 00:11:21,095
所以如果每次它再次运行测试时

279
00:11:21,095 --> 00:11:23,878
它都能看到输出的错误是什么

280
00:11:23,878 --> 00:11:29,444
这让我认为模型可以通过获得这种反馈来收敛到正确的答案

281
00:11:29,628 --> 00:11:34,727
如果你在迭代时没有某种机制来获得反馈

282
00:11:34,727 --> 00:11:37,843
你就不会注入更多的信号

283
00:11:37,864 --> 00:11:38,766
你只会得到噪音

284
00:11:39,708 --> 00:11:41,601
所以没有这样的东西

285
00:11:41,601 --> 00:11:44,758
代理就没有理由收敛到正确的答案

286
00:11:44,938 --> 00:11:45,800
我明白了

287
00:11:45,820 --> 00:11:48,696
那么在提高编码代理性能方面

288
00:11:48,696 --> 00:11:51,130
目前最大的障碍是什么 

289
00:11:51,515 --> 00:11:51,940
是的

290
00:11:51,940 --> 00:11:53,856
所以我认为对于编码

291
00:11:53,856 --> 00:11:55,593
我们在过去一年中

292
00:11:55,593 --> 00:11:58,850
在SweBench上看到的结果

293
00:11:58,850 --> 00:12:00,588
已经从非常非常低

294
00:12:00,588 --> 00:12:02,976
到现在我认为超过50%

295
00:12:02,976 --> 00:12:04,497
这真的非常惊人

296
00:12:04,517 --> 00:12:08,964
所以模型在编写代码解决这些问题方面变得非常好

297
00:12:09,665 --> 00:12:13,904
我觉得我在这里有一个稍微有争议的观点

298
00:12:13,904 --> 00:12:17,437
我认为下一个限制因素将回到验证

299
00:12:17,418 --> 00:12:20,649
对于我们确实有完美单元测试的情况来说

300
00:12:20,649 --> 00:12:21,187
这很好

301
00:12:21,187 --> 00:12:22,803
而且这开始起作用了

302
00:12:22,823 --> 00:12:24,555
但对于现实世界的情况

303
00:12:24,555 --> 00:12:26,806
我们通常没有完美的单元测试

304
00:12:27,367 --> 00:12:29,418
所以这就是我现在想的

305
00:12:29,418 --> 00:12:31,674
找到我们可以验证的方法

306
00:12:31,674 --> 00:12:34,751
并为我们真正关心的事情添加测试

307
00:12:34,751 --> 00:12:37,418
这样模型本身就可以测试这个

308
00:12:37,418 --> 00:12:40,699
并在回到人类之前知道它是对还是错

309
00:12:40,720 --> 00:12:41,100
我明白了

310
00:12:41,861 --> 00:12:45,164
所以确保我们可以在流程中嵌入一些反馈循环

311
00:12:45,385 --> 00:12:45,785
正是如此

312
00:12:45,965 --> 00:12:46,986
对或错

313
00:12:47,894 --> 00:12:48,274
好的

314
00:12:49,436 --> 00:12:51,018
2025年代理的未来会是什么样子 

315
00:12:51,078 --> 00:12:53,280
Barry 我们从你开始

316
00:12:54,101 --> 00:12:54,346
是的

317
00:12:54,346 --> 00:12:56,063
我认为这是一个非常困难的问题

318
00:12:56,924 --> 00:12:59,609
这可能不是一个实际的事情

319
00:12:59,609 --> 00:13:04,532
但我一直非常感兴趣的是多代理环境会是什么样子

320
00:13:04,974 --> 00:13:06,235
我想我已经向Eric展示过这个

321
00:13:06,295 --> 00:13:07,837
我构建了一个环境

322
00:13:07,837 --> 00:13:11,501
其中一堆云可以启动其他云并一起玩狼人杀

323
00:13:12,282 --> 00:13:14,725
什么是狼人杀 

324
00:13:14,745 --> 00:13:17,571
狼人杀是一款社交推理游戏

325
00:13:17,571 --> 00:13:21,339
所有玩家都在试图弄清楚彼此的角色

326
00:13:21,359 --> 00:13:22,422
它和黑手党非常相似

327
00:13:22,542 --> 00:13:23,415
它完全是基于文本的

328
00:13:23,415 --> 00:13:24,969
这对Claude来说非常适合参与

329
00:13:25,270 --> 00:13:25,571
我明白了

330
00:13:25,591 --> 00:13:26,388
所以我们有

331
00:13:26,388 --> 00:13:28,300
多个不同的Claudes

332
00:13:28,300 --> 00:13:29,257
在这个游戏中

333
00:13:29,257 --> 00:13:30,373
扮演不同的角色

334
00:13:30,373 --> 00:13:31,607
彼此之间进行交流

335
00:13:31,768 --> 00:13:32,099
是的

336
00:13:32,099 --> 00:13:32,430
没错

337
00:13:32,410 --> 00:13:37,856
然后你会看到很多以前从未见过的有趣互动

338
00:13:37,876 --> 00:13:39,638
这是让我非常兴奋的事情

339
00:13:39,739 --> 00:13:43,944
这和我们从单一LLM到多LLM的转变非常相似

340
00:13:43,964 --> 00:13:45,108
我认为到今年年底

341
00:13:45,108 --> 00:13:47,827
我们可能会看到从单一代理到多代理的转变

342
00:13:48,389 --> 00:13:52,574
在这个领域有一些有趣的研究问题需要解决

343
00:13:52,594 --> 00:13:55,036
关于代理之间如何互动

344
00:13:55,036 --> 00:13:56,258
这种...

345
00:13:56,238 --> 00:13:58,557
在协调做不同事情的代理时

346
00:13:58,557 --> 00:14:01,070
这种涌现行为会是什么样子 

347
00:14:01,090 --> 00:14:01,792
没错

348
00:14:01,812 --> 00:14:07,486
就像这是否真的会比一个拥有更多资源的单一代理更有用或更好

349
00:14:07,747 --> 00:14:12,880
我们现在有没有看到任何多代理方法在实际生产中有效运作 

350
00:14:13,417 --> 00:14:14,622
我觉得在生产中

351
00:14:14,622 --> 00:14:17,721
我们甚至还没有看到很多成功的单一代理

352
00:14:17,741 --> 00:14:18,551
好的

353
00:14:18,551 --> 00:14:19,362
有趣

354
00:14:19,482 --> 00:14:24,138
但这是成功代理的潜在扩展

355
00:14:24,138 --> 00:14:29,570
随着接下来几代模型能力的提升

356
00:14:31,072 --> 00:14:34,435
所以这并不是建议每个人都去探索多代理环境

357
00:14:34,956 --> 00:14:35,356
只是

358
00:14:35,356 --> 00:14:35,956
我认为

359
00:14:35,956 --> 00:14:37,758
为了理解模型的行为

360
00:14:38,059 --> 00:14:41,201
这为我们提供了一种更好的方式来理解模型行为

361
00:14:41,221 --> 00:14:41,922
我明白了

362
00:14:42,357 --> 00:14:45,301
好的 Eric 2025年代理的未来是什么 

363
00:14:45,321 --> 00:14:47,351
我觉得到2025年

364
00:14:47,351 --> 00:14:53,216
我们会看到很多企业开始采用代理来自动化很多重复性任务

365
00:14:53,216 --> 00:14:58,179
并真正扩大人们以前想做但成本太高的事情的规模

366
00:14:58,259 --> 00:15:02,064
你现在可以做这些事情的10倍或100倍

367
00:15:02,344 --> 00:15:03,397
我想象的是

368
00:15:03,397 --> 00:15:09,293
比如每一个拉取请求都会触发一个编码代理来更新你所有的文档

369
00:15:09,775 --> 00:15:12,155
以前做这样的事情成本太高

370
00:15:12,155 --> 00:15:14,933
但一旦你认为代理几乎是免费的

371
00:15:14,933 --> 00:15:18,305
你就可以开始到处添加这些花哨的功能

372
00:15:19,087 --> 00:15:21,533
我认为可能还有一些事情不会发生

373
00:15:21,533 --> 00:15:23,327
回到什么是被过度炒作的

374
00:15:23,327 --> 00:15:25,936
我觉得消费者代理现在被过度炒作了

375
00:15:25,957 --> 00:15:26,232
好的

376
00:15:26,232 --> 00:15:26,507
来了

377
00:15:26,507 --> 00:15:27,058
热门观点

378
00:15:27,459 --> 00:15:28,803
因为我认为

379
00:15:28,803 --> 00:15:31,224
我们谈到了可验证性

380
00:15:31,244 --> 00:15:34,494
我认为对于很多消费者任务来说

381
00:15:34,494 --> 00:15:40,995
完全指定你的偏好和任务是什么几乎和你自己去做一样多的工作

382
00:15:41,515 --> 00:15:42,936
而且验证起来非常昂贵

383
00:15:43,477 --> 00:15:47,859
所以比如试图让一个代理为你完全预订一个假期

384
00:15:47,859 --> 00:15:53,285
描述你想要的假期和你的偏好几乎和你自己去预订一样困难

385
00:15:53,467 --> 00:15:54,067
有趣

386
00:15:54,087 --> 00:15:55,228
而且风险很高

387
00:15:55,248 --> 00:16:00,053
你不希望代理在你接受之前就去预订航班

388
00:16:00,910 --> 00:16:03,145
我们是否也缺少一些上下文

389
00:16:03,145 --> 00:16:06,497
比如模型能够推断出这些关于某人的信息

390
00:16:06,497 --> 00:16:10,781
而不需要明确地去询问并随着时间的推移学习偏好 

391
00:16:11,182 --> 00:16:11,474
是的

392
00:16:11,474 --> 00:16:13,813
所以我认为这些事情会达到那个程度

393
00:16:13,813 --> 00:16:15,713
但首先你需要建立这个上下文

394
00:16:15,713 --> 00:16:18,491
这样模型就已经知道你在这些事情上的偏好

395
00:16:18,511 --> 00:16:19,572
我认为这需要时间

396
00:16:19,853 --> 00:16:20,173
我明白了

397
00:16:20,474 --> 00:16:22,652
我们需要一些垫脚石来达到更大的任务

398
00:16:22,652 --> 00:16:23,677
比如计划整个假期

399
00:16:23,898 --> 00:16:24,238
我明白了

400
00:16:25,099 --> 00:16:25,913
好的

401
00:16:25,913 --> 00:16:27,542
非常有趣

402
00:16:27,775 --> 00:16:28,838
最后一个问题

403
00:16:28,838 --> 00:16:31,319
对于正在探索这个领域的开发者

404
00:16:31,319 --> 00:16:32,382
你有什么建议

405
00:16:32,382 --> 00:16:36,636
无论是从开始构建这个还是从一般未来证明的角度考虑

406
00:16:36,636 --> 00:16:38,230
你能给出什么建议 

407
00:16:38,932 --> 00:16:44,200
我觉得我最好的建议是确保你有办法衡量你的结果

408
00:16:44,240 --> 00:16:47,341
因为我看到很多人会在真空中构建

409
00:16:47,341 --> 00:16:51,891
没有任何方式获得反馈来了解他们的构建是否有效

410
00:16:52,312 --> 00:16:56,718
你可能会构建很多东西而没有意识到它要么不起作用

411
00:16:56,718 --> 00:17:00,549
要么可能更简单的东西实际上也能做得同样好

412
00:17:01,070 --> 00:17:01,586
是的

413
00:17:01,586 --> 00:17:02,879
我非常同意

414
00:17:02,879 --> 00:17:04,688
尽可能简单开始

415
00:17:04,688 --> 00:17:09,340
并在构建更多复杂性时拥有可衡量的结果

416
00:17:10,241 --> 00:17:11,825
我印象深刻的一件事是

417
00:17:11,825 --> 00:17:14,359
我和一些非常有资源的初创公司合作

418
00:17:14,359 --> 00:17:17,369
他们可以在一个ILM调用中完成所有事情

419
00:17:17,509 --> 00:17:19,367
围绕代码的编排

420
00:17:19,367 --> 00:17:21,491
即使模型变得更好

421
00:17:21,491 --> 00:17:23,880
这部分也会持续存在

422
00:17:23,880 --> 00:17:25,739
这是他们的专长

423
00:17:25,759 --> 00:17:27,408
每当我看到这些时

424
00:17:27,408 --> 00:17:28,852
我总是非常高兴

425
00:17:28,852 --> 00:17:31,533
因为我认为他们可以从中获益

426
00:17:31,533 --> 00:17:33,389
比如未来的能力提升

427
00:17:35,314 --> 00:17:35,903
实际上

428
00:17:35,903 --> 00:17:39,247
我们不知道哪种用例对代理来说会很好

429
00:17:39,247 --> 00:17:41,606
而且这个领域将会发生变化

430
00:17:41,627 --> 00:17:47,375
但现在可能是开始建立一些思考代理领域的能力的好时机

431
00:17:47,375 --> 00:17:50,364
只是为了更好地理解这种能力

432
00:17:50,446 --> 00:17:50,730
是的

433
00:17:50,730 --> 00:17:54,712
我想我想深入探讨一下你提到的对模型变得更好感到兴奋的事情

434
00:17:55,214 --> 00:17:55,693
我认为

435
00:17:55,693 --> 00:17:57,932
如果你看看你的初创公司或产品

436
00:17:57,932 --> 00:17:58,412
然后想

437
00:17:58,412 --> 00:17:58,572
哦

438
00:17:58,572 --> 00:18:00,011
如果模型变得更聪明

439
00:18:00,011 --> 00:18:01,931
我们所有的护城河都会消失

440
00:18:01,931 --> 00:18:04,170
这意味着你正在构建错误的东西

441
00:18:04,190 --> 00:18:04,425
相反

442
00:18:04,425 --> 00:18:05,486
你应该构建一些东西

443
00:18:05,486 --> 00:18:06,782
以便随着模型变得更聪明

444
00:18:06,782 --> 00:18:08,196
你的产品也会变得越来越好

445
00:18:08,457 --> 00:18:08,697
对

446
00:18:09,398 --> 00:18:10,801
这是个很好的建议

447
00:18:11,262 --> 00:18:12,484
Eric Barry 谢谢你们

448
00:18:12,945 --> 00:18:14,247
这是构建有效代理

449
00:18:14,427 --> 00:18:14,768
谢谢

450
00:18:15,549 --> 00:18:16,150
谢谢

